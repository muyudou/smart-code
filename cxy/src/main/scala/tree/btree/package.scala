package tree

/**
 * b-tree的定义参考《算法导论》: 从树的最小度 t 出发, t >= 2, m = 2*t
 * 1. 除了根节点外，每个节点至少有 t-1 个关键字，最多有 2t-1个关键字，最少有 t 个子节点，最多有 2*t 个子节点
 * 2. 叶子节点在同一层
 * 3. 树高度增加的唯一方式：在插入时，发现 root 节点已经满了，先分裂它
 * 3. 树高度减少的唯一方式: 在删除时，需要从父节点中拿一个关键字和子节点合并，如果此时父节点中只有一个关键字，那么父节点就是root,
 *    root 有两个子节点，此时把 root 和两个子节点合并成新的 root 节点
 *
 * 1. 插入: 插入只发生在叶节点，因此比较简单
 *   关键点：在插入的过程中可能发生分裂，会把一个关键字上移到父节点中，需要保证父节点此时是不满的。为了减少两次遍历，在插入的过程中，
 *          我们每当遇到一个满的节点，立刻分裂它。
 *
 * 2. 删除：删除可能发生在任意节点上，因此比较复杂，这里分4种情况讨论
 * 关键点：在递归下降的过程中，保证遇到的每个节点都至少有 t 个关键字，因为在递归下降的过程中可能需要把关键字下移到它的子节点中
 * 2.1 当前节点是叶子节点，并且 key 不在节点中，说明树中不包含该节点，不需要做任何处理。
 * 2.2 当前节点是叶子节点，并且 key 在节点中，按照之前的保证此时节点中至少有 t 个关键字，所以可以直接删除
 *
 * 2.3 当前节点是内部节点，并且 key 在节点中，假设该 key 对应的两个子节点分别是 x, y
 *   1) 如果 x 有至少 t 个关键字，删除 x 子树中的最大关键字，使用它替代 key
 *   2) 如果 y 有至少 t 个关键字，删除 y 子树中的最小关键字，使用它替代 key
 *   3) 此时 x 和 y 都只有 t-1 个关键字，则把 x, key, y 合并到 其中一个节点中，在新合并的节点中继续删除。
 *
 * 2.3 当前节点是内部节点，并且 key 不在节点中，index 指向了 2 的位置, 递归下降到子节点 c 处，但是在下降之前需要确保 c 至少有 t 个键,
 *     +---+---+---+---+---+
       | 0 | 1 | 2 | 3 | 4 |
       +---+---+---+---+---+
               /   |   \
             +-+  +-+  +-+
             |y|  |c|  |z|
             +-+  +-+  +-+
 * 如果 c 只有 t-1 个键，有两种可能性:
 * 1) 如果 y 有至少 t 个键，则把父节点中的键2 下降到 c 中，把 y 中的最大值提升到父节点中，同时把 y 最大的子节点作为 c  的第一个子节点,
 *    同样的，如果 z 中有至少 t 个键，则可以从 z 中借一个键
 * 2）如果无法从 y 和 z 中借键，c 可以和它的某一个兄弟节点合并，有两种合并方式:
 *    a. y, 2, c
 *    b. c, 3, z
 * 注意: y 和 z 可能有一个为空
 */
package object btree {

}
